--[[
	Package link auto-generated by Rotriever
]]
local PackageIndex = script.Parent.Parent.Parent._Index

local Package = require(PackageIndex["Utils-debf4142-0.3.1"]["Utils"])

export type TypeAndFieldToDirectives = Package.TypeAndFieldToDirectives
export type SchemaPrintOptions = Package.SchemaPrintOptions
export type GetDocumentNodeFromSchemaOptions = Package.GetDocumentNodeFromSchemaOptions
export type PrintSchemaWithDirectivesOptions = Package.PrintSchemaWithDirectivesOptions
export type Maybe<T> = Package.Maybe<T> 
export type Constructor<T> = Package.Constructor<T> 
export type PruneSchemaFilter = Package.PruneSchemaFilter
export type InputLeafValueTransformer = Package.InputLeafValueTransformer
export type InputObjectValueTransformer = Package.InputObjectValueTransformer
export type ASTVisitorKeyMap = Package.ASTVisitorKeyMap
export type DirectiveLocationEnum = Package.DirectiveLocationEnum
export type DirectiveLocation = Package.DirectiveLocation
export type ExtensionsObject = Package.ExtensionsObject
export type ObjectTypeExtensions = Package.ObjectTypeExtensions
export type InputTypeExtensions = Package.InputTypeExtensions
export type InterfaceTypeExtensions = Package.InterfaceTypeExtensions
export type UnionTypeExtensions = Package.UnionTypeExtensions
export type ScalarTypeExtensions = Package.ScalarTypeExtensions
export type EnumTypeExtensions = Package.EnumTypeExtensions
export type PossibleTypeExtensions = Package.PossibleTypeExtensions
export type SchemaExtensions = Package.SchemaExtensions
export type DirectiveArgs = Package.DirectiveArgs
export type DirectiveUsage = Package.DirectiveUsage
export type ExecutionResult<TData = { [string]: any }> = Package.ExecutionResult<TData > 
export type ExecutionRequest<
	TArgs = { [string]: any },
	TContext = any,
	TRootValue = any,
	TExtensions = { [string]: any }
> = Package.ExecutionRequest<
	TArgs ,
	TContext ,
	TRootValue ,
	TExtensions > 
export type GraphQLParseOptions = Package.GraphQLParseOptions
export type ValidatorBehavior = Package.ValidatorBehavior
export type IResolverValidationOptions = Package.IResolverValidationOptions
export type IAddResolversToSchemaOptions = Package.IAddResolversToSchemaOptions
export type IScalarTypeResolver = Package.IScalarTypeResolver
export type IEnumTypeResolver = Package.IEnumTypeResolver
export type IFieldResolverOptions<TSource = any, TContext = any, TArgs = any> = Package.IFieldResolverOptions<TSource , TContext , TArgs > 
export type FieldNodeMapper = Package.FieldNodeMapper
export type FieldNodeMappers = Package.FieldNodeMappers
export type InputFieldFilter = Package.InputFieldFilter
export type FieldFilter = Package.FieldFilter
export type ObjectFieldFilter = Package.ObjectFieldFilter
export type RootFieldFilter = Package.RootFieldFilter
export type TypeFilter = Package.TypeFilter
export type ArgumentFilter = Package.ArgumentFilter
export type RenameTypesOptions = Package.RenameTypesOptions
export type IFieldResolver<TSource, TContext, TArgs = { [string]: any }, TReturn = any> = Package.IFieldResolver<TSource, TContext, TArgs , TReturn > 
export type TypeSource = Package.TypeSource
export type IObjectTypeResolver<TSource = any, TContext = any, TArgs = any> = Package.IObjectTypeResolver<TSource , TContext , TArgs > 
export type IInterfaceTypeResolver<TSource = any, TContext = any, TArgs = any> = Package.IInterfaceTypeResolver<TSource , TContext , TArgs > 
export type IUnionTypeResolver = Package.IUnionTypeResolver
export type IInputObjectTypeResolver = Package.IInputObjectTypeResolver
export type ISchemaLevelResolver<TSource, TContext, TArgs = { [string]: any }, TReturn = any> =
Package.ISchemaLevelResolver<TSource, TContext, TArgs , TReturn > 
export type IResolvers<TSource = any, TContext = any, TArgs = { [string]: any }, TReturn = any> =
Package.IResolvers<TSource , TContext , TArgs , TReturn > 
export type IFieldIteratorFn = Package.IFieldIteratorFn
export type IDefaultValueIteratorFn = Package.IDefaultValueIteratorFn
export type NextResolverFn = Package.NextResolverFn
export type VisitableSchemaType = Package.VisitableSchemaType
export type MapperKind = Package.MapperKind
export type SchemaMapper = Package.SchemaMapper
export type SchemaFieldMapperTypes = Package.SchemaFieldMapperTypes
export type NamedTypeMapper = Package.NamedTypeMapper
export type ScalarTypeMapper = Package.ScalarTypeMapper
export type EnumTypeMapper = Package.EnumTypeMapper
export type EnumValueMapper = Package.EnumValueMapper
export type CompositeTypeMapper = Package.CompositeTypeMapper
export type ObjectTypeMapper = Package.ObjectTypeMapper
export type InputObjectTypeMapper = Package.InputObjectTypeMapper
export type AbstractTypeMapper = Package.AbstractTypeMapper
export type UnionTypeMapper = Package.UnionTypeMapper
export type InterfaceTypeMapper = Package.InterfaceTypeMapper
export type DirectiveMapper = Package.DirectiveMapper
export type GenericFieldMapper<F> = Package.GenericFieldMapper<F> 
export type FieldMapper = Package.FieldMapper
export type ArgumentMapper = Package.ArgumentMapper
export type InputFieldMapper = Package.InputFieldMapper
export type ValueVisitor = Package.ValueVisitor
export type ObjectValueVisitor = Package.ObjectValueVisitor
export type ResultVisitorMap = Package.ResultVisitorMap
export type ErrorVisitor = Package.ErrorVisitor
export type ErrorVisitorMap = Package.ErrorVisitorMap
export type AsyncExecutor<TBaseContext = { [string]: any }, TBaseExtensions = { [string]: any }> =
Package.AsyncExecutor<TBaseContext , TBaseExtensions > 
export type SyncExecutor<TBaseContext = { [string]: any }, TBaseExtensions = { [string]: any }> =
Package.SyncExecutor<TBaseContext , TBaseExtensions > 
export type Executor<TBaseContext = { [string]: any }, TBaseExtensions = { [string]: any }> = Package.Executor<TBaseContext , TBaseExtensions > 
export type NamedDefinitionNode = Package.NamedDefinitionNode
-- ROBLOX deviation END


return Package
